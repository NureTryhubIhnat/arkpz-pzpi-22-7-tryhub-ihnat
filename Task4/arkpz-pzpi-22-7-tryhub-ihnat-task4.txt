Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Кафедра програмної інженерії

Звіт
З лабораторної роботи №4
З дисципліни «Аналіз та рефакторинг коду»
на тему: «РОЗРОБКА IoT КЛІЄНТА»

Виконав

Перевірив ст.

ст. гр. ПЗПІ-22-7

викладач каф. ПІ

Тригуб І.О.

Сокорчук І. П.

Харків 2024

1 МЕТА РОБОТИ
Розробити клієнт IoT, який здійснює збір, аналіз і передачу даних на сервер
відповідно до принципів Інтернету речей. Реалізувати бізнес-логіку, функціонал
налаштування пристрою та забезпечити інтеграцію з іншими компонентами
системи.
2 ХІД РОБОТИ
В ході виконання лабораторної роботи було реалізовано IoT-систему
моніторингу здоров'я на базі мікроконтролера ESP32, що включає кілька
ключових інженерних рішень для забезпечення ефективності та стабільної
роботи пристрою:
• Розроблено програмний код для взаємодії з сенсорами температури,
пульсу та кроків. Пристрій вимірює ці параметри та відображає їх на OLEDдисплеї.
• Використано Wi-Fi модуль ESP32 для з'єднання з мережею та
передавання даних на MQTT брокер для віддаленого моніторингу.
• Створено механізм збору та обробки даних з DS18B20 (температура),
пульсового сенсора (пульс) та MPU6050 (кроки), що дозволяє здійснювати точне
вимірювання та передачу даних.
• Реалізовано відображення зібраних даних у реальному часі на OLED
дисплеї, що дозволяє користувачу відразу бачити важливі показники здоров'я.
• Забезпечено інтеграцію IoT-пристрою з MQTT сервером, що дозволяє
передавати дані у форматі JSON на віддалений клієнт для моніторингу.
• Здійснено тестування пристрою через серійний монітор для перевірки
коректності з'єднання з Wi-Fi мережею та MQTT сервером.
2.1 Текстовий опис інженерних рішень

Програмний код IoT-пристрою реалізований за допомогою Arduino IDE з
використанням таких бібліотек, як:
• WiFi.h для з'єднання з Wi-Fi мережею.
• Wire.h, Adafruit_GFX.h та Adafruit_SSD1306.h для роботи з OLED
дисплеєм.
• DallasTemperature.h та OneWire.h для роботи з датчиком температури
DS18B20.
• Adafruit_MPU6050.h для роботи з акселерометром та гіроскопом
MPU6050.
• PubSubClient.h для передачі даних через MQTT.
Основні етапи виконання роботи:
• Підключення до Wi-Fi: Автоматичне встановлення з'єднання з заданою
мережею.
• Зчитування та обробка даних сенсорів: Збір даних про температуру, пульс
та кроки.
• Відображення даних на OLED дисплеї: Реальне відображення важливих
параметрів для користувача.
• Передача даних на MQTT сервер: Надсилання зібраних даних у форматі
JSON для віддаленого моніторингу.
• Логування: Виведення діагностичної інформації для перевірки
працездатності системи через серійний монітор.

Рисунок 2.1 – Схема IoT пристрою
2.2 Фрагменти програмного коду
2.2.1 Бізнес-логіка IoT-клієнта
Фрагмент коду зчитування даних сенсорів:
Код наведено у додатку А.
2.2.2 Налаштування IoT-клієнта
Фрагмент коду підключення до Wi-Fi:
1. // Wi-Fi credentials
2. const char* ssid = "Wokwi-GUEST";
3. const char* password = "";

// Network SSID

// Network password

4. void setup() {
5.

Serial.begin(115200);

6.

// Connect to Wi-Fi

7.

WiFi.begin(ssid, password);

8.

while (WiFi.status() != WL_CONNECTED) {

9.

delay(1000);

10.

Serial.println("Connecting to WiFi...");

11.

}

12.

Serial.println("WiFi connected");

13.

Serial.println("IP Address: " + WiFi.localIP().toString());

14. }

2.3 UML Діаграми
2.3.1 Діаграма прецедентів IoT клієнта

Рисунок 2.3.1 – UML діаграма прецедентів IoT клієнта
Діаграма прецедентів описує взаємодію IoT-клієнта з користувачем, Wi-Fi,
MQTT-брокером,

датчиком

температури

та

акселерометром.

Основні

прецеденти включають підключення до Wi-Fi, збір даних із сенсорів та
відправлення даних на MQTT-брокер.

2.3.2 Діаграма діяльності IoT клієнта

Рисунок 2.3.2– UML діаграма діяльності IoT клієнта
Діаграма діяльності відображає повний процес роботи IoT-клієнта,
починаючи з ініціалізації системи та встановлення з'єднання з Wi-Fi мережею. У
разі успішного підключення клієнт ініціалізує сенсори, щоб почати збір даних
про температуру та дані з акселерометра.
Після отримання даних від сенсорів система обробляє інформацію і готує
її до відправки. Потім IoT-клієнт намагається надіслати дані на MQTT-брокер.
Якщо надсилання даних відбувається успішно, на екрані з'явиться повідомлення
про підтвердження успішного надсилання. У разі невдачі надсилання,
виводиться повідомлення про збій передачі даних.

3 ВИСНОВКИ
У ході виконання лабораторної роботи було успішно розроблено IoTклієнт для моніторингу здоров'я, який відповідає сучасним вимогам до
розумних пристроїв та IoT-систем. Реалізовано ефективний збір, обробку та
передачу даних з використанням сенсорів для вимірювання температури,
пульсу та кроків. Завдяки налаштуванню клієнта на передачу даних через
MQTT, забезпечено можливість інтеграції цього пристрою в більш масштабні
системи для віддаленого моніторингу стану здоров'я. Це підтверджує
практичну цінність розробленого IoT-клієнта для застосування в медичних та
фітнес-системах.
Посилання на відео: https://youtu.be/4sVBL9PWajk

Додаток А
1. // Temperature Sensor Settings
2. #define ONE_WIRE_BUS 23

// Define pin for DS18B20 (GPIO23)

3. OneWire oneWire(ONE_WIRE_BUS);
4. DallasTemperature temperatureSensors(&oneWire);
5. // Accelerometer and Gyroscope Settings
6. Adafruit_MPU6050 mpu;
7. sensors_event_t accelerometer, gyroscope, temp;
8. const float STEP_THRESHOLD = 1.5; // Adjust this value to fine-tune step detection
9. float accMag, gyroMag;
10. int stepCount = 0;
11. void setup() {
12.

Serial.begin(115200);

13.

// Initialize sensors

14.

temperatureSensors.begin();

15.

if (!mpu.begin()) {

16.

Serial.println("MPU6050 Error!");

17.

while (true);

18.

}

19.

// Additional setup...

20. }
21. void loop() {
22.

// Get temperature

23.

temperatureSensors.requestTemperatures();

24.

float temperature = temperatureSensors.getTempCByIndex(0);

25.

Serial.print("Temperature: ");

26.

Serial.println(temperature);

27.

// Get accelerometer and gyroscope readings

28.

mpu.getEvent(&accelerometer, &gyroscope, &temp);

29.

accMag

=

sqrt(sq(accelerometer.acceleration.x)

+

sq(accelerometer.acceleration.y) + sq(accelerometer.acceleration.z));
30.

gyroMag

=

sqrt(sq(gyroscope.gyro.x)

sq(gyroscope.gyro.z));
31.

// Display accelerometer and gyroscope data

32.

Serial.print("Accelerometer Magnitude: ");

+

sq(gyroscope.gyro.y)

+

33.

Serial.println(accMag);

34.

Serial.print("Gyroscope Magnitude: ");

35.

Serial.println(gyroMag);

36.

// Step detection

37.

if (accMag > STEP_THRESHOLD || gyroMag > STEP_THRESHOLD) {

38.

stepCount++;

39.

Serial.print("Steps: ");

40.

Serial.println(stepCount);

41.

}

42.

delay(1000); // Wait for 1 second before next reading

43. }


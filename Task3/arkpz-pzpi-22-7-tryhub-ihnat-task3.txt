Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії
Звіт
З лабораторної роботи №3
З дисципліни «Аналіз та рефакторинг коду»
на тему: «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ
АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ
СИСТЕМИ »
Виконавець:
ст. гр. ПЗПІ-22-7

Тригуб І. О.

Перевірив:
ст. викладач кафедри ПІ

Сокорчук І. П.

Харків 2024

1 МЕТА РОБОТИ
Метою роботи є розробка бізнес-логіки та функцій адміністрування
для серверної частини програмної системи.
2 ХІД РОБОТИ
В ході виконання лабораторної роботи було впроваджено ряд функцій,
які охоплюють основні аспекти адміністрування, безпеки та аналізу даних.
Опис інженерних рішень включає:
Управління користувачами:
•

Отримання всіх користувачів з бази даних.

•

Видалення користувачів за унікальним ідентифікатором (ID).

Управління сповіщеннями:
•

Створення нових сповіщень та їх збереження у базу даних.

•

Отримання списку всіх сповіщень.

•

Видалення конкретного сповіщення за ID.

Робота з даними про здоров'я:
•

Додавання даних про стан здоров’я користувача (пульс, рівень

активності тощо).
•

Отримання цих даних для аналітики.

Оновлення токенів:
•

Реалізація механізму рефрешу токенів для оновлення сесії

користувача.
Фрагменти програмного коду
•

Функції роботи зі сповіщеннями:

1. router.post("/notification", adminController.addNotification);
2. router.get("/notifications", adminController.getNotification);
3. router.delete("/notifications/:id", adminController.deleteNotification);

Код з програмної реалізації маршрутів наведено у додатку В

•

Функції роботи з користувачами:

1. async getUsers(req, res, next) {
2.

try {

3.

const users = await userService.getAllUsers();

4.

return res.json(users);

5.

} catch (e) {

6.

next(e);

7.

}

8. }
9. async deleteUser(req, res, next) {
10.

try {

11.

const { id } = req.params;

12.

await User.findByIdAndDelete(id);

13.

res.json({ message: "User deleted successfully" });

14.

} catch (e) {

15.

next(e);

16.

}

17. }
•

Функції роботи з даними про здоров’я:

1. router.get("/health/data", adminController.getUserHelthData);
2. router.post("/health/data", adminController.addUserHealthData);

Код з програмної реалізації маршрутів наведено у додатку Г
3 ВИСНОВКИ
Під час виконання лабораторної роботи було реалізовано кілька
функцій, що охоплюють основні аспекти адміністрування, безпеки та
аналізу даних. Зокрема, були розроблені рішення для управління
користувачами, сповіщеннями та даними про здоров'я, що значно
покращують ефективність системи та зручність її використання.
Управління користувачами реалізовано через можливість отримання
списку всіх користувачів з бази даних та видалення користувачів за
унікальним ідентифікатором (ID). Це дозволяє адміністраторам системи

ефективно керувати обліковими записами користувачів, забезпечуючи
належний рівень контролю та безпеки.
Управління сповіщеннями включає функціонал для створення,
збереження та отримання сповіщень з бази даних, а також їх видалення за
ID. Це дозволяє своєчасно інформувати користувачів про важливі події або
зміни в системі, покращуючи комунікацію та взаємодію з користувачами.
Робота з даними про здоров'я передбачає додавання даних про стан
здоров'я користувачів, таких як пульс, рівень активності, стрес та тривалість
сну. Цей функціонал дозволяє проводити аналіз стану здоров'я користувачів,
надаючи корисну інформацію для подальших рішень.
Оновлення токенів здійснюється через механізм рефрешу токенів для
оновлення сесії користувача, що забезпечує безперервність авторизації та
захищає дані користувачів.
Усі ці функції сприяють підвищенню зручності користування
системою та її надійності, а також дають можливість ефективно обробляти
дані та здійснювати адміністративні дії.
Посилання на ютуб - https://youtu.be/Kf00ZbRub58

ДОДАТОК А
UML діаграма отримання всіх користувачів

Рисунок А.1 – UML отримання всіх користувачів
Діаграма описує процес отримання списку користувачів, починаючи
від клієнта та закінчуючи поверненням результату з бази даних.

ДОДАТОК Б
UML діаграми активності

Рисунок Б.1 – UML діаграма створення сповіщення
Діаграма на рис. Б.1 активності демонструє логіку перевірки та
створення нового сповіщення в системі.

Рисунок Б.2 – UML діаграма видалення користувача

Діаграма на рис. Б.2 описує, як система опрацьовує запит на
видалення користувача.

Рисунок Б.3 – UML діаграма отримання сповіщень
Діаграма на рис. Б.3 демонструє процес отримання всіх сповіщень для
адміністратора.

Рисунок Б.4 – UML діаграма додавання даних здоров’я користувача

Діаграма на рис. Б.4 показує, як система додає інформацію про
здоров’я користувача у базу даних після валідації вхідних даних.

Рисунок Б.5 – UML діаграма видалення сповіщення
Діаграма на рис. Б.5 ілюструє, як система обробляє запит на
видалення сповіщення.

ДОДАТОК В
Код з програмної реалізації маршрутів для сповіщень (із серверної
частини)
1. async createNotification(req, res, next) {
2.

try {

3.

const errors = validationResult(req);

4.

if (!errors.isEmpty()) {

5.
return next(ApiError.BadRequest("Помилка при валідації",
errors.array()));
6.

}

7.

const { email, password, role } = req.body;

8.
res.status(201).json({ message: "Notification created
successfully." });
9.

} catch (e) {

10.

next(e);

11.

}

12. }

13. async deleteNotification(req, res, next) {
14.

try {

15.

const { id } = req.params;

16.

await Notification.findByIdAndDelete(id);

17.

res.json({ message: "Notification deleted successfully" });

18.

} catch (e) {

19.
20.
21. }

res.status(500).json({ message: "Error deleting notification" });
}

ДОДАТОК Г
Код з програмної реалізації маршрутів для роботи з даними про здоров’я
(із серверної частини)
1. async addUserHealthData(req, res, next) {
2.

try {

3.

const { userId, pulse, activityLevel, stressLevel, sleepHours } =

req.body;
4.

if (!userId || !pulse || !activityLevel || !stressLevel || !sleepHours)

{
5.

return res.status(400).json({ error: "Invalid input data" });

6.

}

7.

res.status(201).json({ message: "Data successfully added" });

8.

} catch (e) {

9.

next(e);

10.

}

11. }
12. async getUserHelthData(req, res, next) {
13.

const { userId } = req.query;

14.

if (!userId) {

15.

return res.status(400).json({ error: "userId is required" });

16.

}

17.

const data = {

18.

userId,

19.

pulse: 70,

20.

activityLevel: 3,

21.

stressLevel: 2,

22.

sleepHours: 7,

23.

};

24.

res.status(200).json(data);

25. }

